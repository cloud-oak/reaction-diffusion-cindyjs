<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<script type="text/javascript" src="https://cindyjs.org/dist/snapshot/Cindy.js"></script>
		<script type="text/javascript" src="https://cindyjs.org/dist/snapshot/CindyGL.js"></script>
		<title>3dgol</title>
	</head>

	<body style="background:#000;">
		<div id="CSCanvas" class="CindyJS-widget" style="position: relative; width: 512px; height: 512px;"></div>
		<script id="csdraw" type="text/x-cindyscript">
			// repeat(10, colorplot((0, 0), (statewidth, 0), "state", newstate(#)));
			colorplot((0,0), (statewidth,0), "spect", imagergb((0,0), (statewidth,0), "state", #));
			fft();
			colorplot((0,0), (statewidth,0), "spect",
				F = imagergb((0,0), (statewidth,0), "spect", #);
				K = imagergb((0,0), (statewidth,0), "kernel", #);
				[F.x * K.x - F.y * K.y, F.x * K.y + F.y * K.x, 0];
			);
			ifft();
			colorplot((0,0), (statewidth,0), "laplacian", imagergb((0,0), (statewidth,0), "spect", #));
			colorplor((0,0), (statewidth,0), "state", newstate(#));

			// Ab hier: 3D
			origin = zoom * EXTENT * [
				cos(lambda)*cos(phi),
				sin(phi),
				sin(lambda)*cos(phi)
			] + target;
			mdir = (target-origin)/|(target-origin)|;
			v = cross([0,1,0], mdir);
			w = cross(mdir, v);
			v = v/|v|;
			w = w/|w|;
			colorplot(
				dir = mdir + #.x*v + #.y*w;
				raytraceiso()
			);
		</script>
		<script id="csinit" type="text/x-cindyscript">
			EXPONENT = 6;
			EXTENT = 2 ^ EXPONENT; // Extent of the cube for each dimension

			target = [EXTENT,EXTENT,EXTENT]/2;
			statewidth   = EXTENT * EXTENT;
			stateheight  = EXTENT;
			while(statewidth > 2 * stateheight,
				statewidth  = statewidth / 2;
				stateheight = stateheight * 2;
			);
			TILESX = statewidth / EXTENT;
			TILESY = stateheight / EXTENT;
			print(statewidth + " x " + stateheight);
			lambda = pi / 6;
			phi = pi / 8;
			zoom = 1.1;
			createimage("state", statewidth, stateheight);
			createimage("spect", statewidth, stateheight);
			createimage("kernel", statewidth, stateheight);
			createimage("laplacian", statewidth, stateheight);

			kernel = 6*[[
				[0.01, 0.03, 0.01],
				[0.03, 0.09, 0.03],
				[0.01, 0.03, 0.01]
			], [
				[0.03, 0.09, 0.03],
				[0.09, -0.98, 0.09],
				[0.03, 0.09, 0.03]
			], [
				[0.01, 0.03, 0.01],
				[0.03, 0.09, 0.03],
				[0.01, 0.03, 0.01]
			]];


			complex2color(c) := (
			  // c = c/encodealpha+encodedelta;
			  (re(c), im(c), 0)
			);

			readcomplex(x,y,z) := (
				color = imagergb((0, 0), (statewidth, 0), "spect",
					(floor(p.x) + EXTENT * mod(floor(p.z), TILESX),
					floor(p.y) + EXTENT * floor(floor(p.z) / TILESX)),
					interpolate->false, repeat->false
				);
			  // encodealpha*(color.x + i*color.y-encodedelta);
			  color.x + i * color.y;
			);

			fft() := (
				step = 2^(EXPONENT-1);
				while(step >= 1,
					colorplot((0,0), (W, 0), "spect",
						pt = spacepoint(#);
						l = pt.x;
						delta = mod(l,step); //shift
						k = (l-delta) / step;
						evens = readcomplex(2*l - delta,        pt.y, pt.z);
						odds  = readcomplex(2*l - delta + step, pt.y, pt.z);
						complex2color((evens + exp((-2*pi*i/W*step)*k)*odds));
					);
					step = step / 2;
				);
				step = 2^(EXPONENT-1);
				while(step >= 1,
					colorplot((0,0), (W, 0), "spect",
						pt = spacepoint(#);
						l = pt.y;
						delta = mod(l,step); //shift
						k = (l-delta) / step;
						evens = readcomplex(pt.x, 2*l - delta,        pt.z);
						odds  = readcomplex(pt.x, 2*l - delta + step, pt.z);
						complex2color((evens + exp((-2*pi*i/W*step)*k)*odds));
					);
					step = step / 2;
				);
				step = 2^(EXPONENT-1);
				while(step >= 1,
					colorplot((0,0), (W, 0), "spect",
						pt = spacepoint(#);
						l = pt.z;
						delta = mod(l,step); //shift
						k = (l-delta) / step;
						evens = readcomplex(pt.x, pt.y, 2*l - delta,      );
						odds  = readcomplex(pt.x, pt.y, 2*l - delta + step);
						
						complex2color((evens + exp((-2*pi*i/W*step)*k)*odds));
					);
					step = step / 2;
				);
			);

			ifft() := (
				step = 2^(EXPONENT-1);
				while(step >= 1,
					colorplot((0,0), (W, 0), "spect",
						pt = spacepoint(#);
						l = pt.x;
						delta = mod(l,step); //shift
						k = (l-delta) / step;
						evens = readcomplex(2*l - delta,        pt.y, pt.z);
						odds  = readcomplex(2*l - delta + step, pt.y, pt.z);
						if(step == 1,
							complex2color((evens + exp((2*pi*i/W*step)*k)*odds) / W),
							complex2color((evens + exp((2*pi*i/W*step)*k)*odds))
						);
					);
					step = step / 2;
				);
				step = 2^(EXPONENT-1);
				while(step >= 1,
					colorplot((0,0), (W, 0), "spect",
						pt = spacepoint(#);
						l = pt.y;
						delta = mod(l,step); //shift
						k = (l-delta) / step;
						evens = readcomplex(pt.x, 2*l - delta,        pt.z);
						odds  = readcomplex(pt.x, 2*l - delta + step, pt.z);
						if(step == 1,
							complex2color((evens + exp((2*pi*i/W*step)*k)*odds) / W),
							complex2color((evens + exp((2*pi*i/W*step)*k)*odds))
						);
					);
					step = step / 2;
				);
				step = 2^(EXPONENT-1);
				while(step >= 1,
					colorplot((0,0), (W, 0), "spect",
						pt = spacepoint(#);
						l = pt.z;
						delta = mod(l,step); //shift
						k = (l-delta) / step;
						evens = readcomplex(pt.x, pt.y, 2*l - delta,      );
						odds  = readcomplex(pt.x, pt.y, 2*l - delta + step);
						if(step == 1,
							complex2color((evens + exp((2*pi*i/W*step)*k)*odds) / W),
							complex2color((evens + exp((2*pi*i/W*step)*k)*odds))
						);
					);
					step = step / 2;
				);
			);

			colorplot((0,0), (statewidth,0), "spect",
				pt = spacepoint(#);
				if(pt.x > EXTENT/2, pt.x=EXTENT-pt.x);
				if(pt.y > EXTENT/2, pt.y=EXTENT-pt.y);
				if(pt.z > EXTENT/2, pt.z=EXTENT-pt.z);
				if(|pt| == 1,
					[1,0,0]
				, if(|pt| == 0,
					[-6,0,0],
					[0,0,0]
				))
			);
			colorplot((0,0), (statewidth,0), "kernel", imagergb((0,0), (statewidth,0), "spect", #));
			
			spacepoint(t) := (
				mod(t.x, EXTENT),
				mod(t.y, EXTENT),
				floor(t.x / EXTENT) + TILESX * floor(t.y / EXTENT)
			);
			

			voxelAt(p) := (
				if(p.x<0 % p.y < 0 % p.z < 0 % p.x >= EXTENT % p.y >= EXTENT % p.z >= EXTENT,
					0
				,
					imagergb((0, 0), (statewidth, 0), "state",
						(floor(p.x) + EXTENT * mod(floor(p.z), TILESX),
						floor(p.y) + EXTENT * floor(floor(p.z) / TILESX)),
						interpolate->false, repeat->false
					).g
				)
			);

			// Trilinear interpolation of voxels (for isosurfaces)
			valAt(p) := (
				if(p.x<0 % p.y < 0 % p.z < 0 % p.x >= EXTENT % p.y >= EXTENT % p.z >= EXTENT,
					0
				,
					lz = p.z - floor(p.z);
					
					(1-lz) * imagergb((0, 0), (statewidth, 0), "state", (
						p.x + EXTENT * mod(floor(p.z), TILESX),
						p.y + EXTENT * floor(floor(p.z) / TILESX)
					), interpolate->true, repeat->false).g +
					lz *  imagergb((0, 0), (statewidth, 0), "state", (
						p.x + EXTENT * mod(ceil(p.z), TILESX),
						p.y + EXTENT * floor(ceil(p.z) / TILESX)
					), interpolate->true, repeat->false).g
				)
			);

			get(p) := (
				// if(p.x<0, p.x = p.x + EXTENT, if(p.x>=EXTENT, p.x = p.x - EXTENT));
				// if(p.y<0, p.y = p.y + EXTENT, if(p.y>=EXTENT, p.y = p.y - EXTENT));
				// if(p.z<0, p.z = p.z + EXTENT, if(p.z>=EXTENT, p.z = p.z - EXTENT));
				if(p.x<0 % p.y < 0 % p.z < 0 % p.x >= EXTENT % p.y >= EXTENT % p.z >= EXTENT,
					[0, 0, 0]
				,
					imagergb((0, 0), (statewidth, 0), "state",
						(floor(p.x) + EXTENT * mod(floor(p.z), TILESX),
						floor(p.y) + EXTENT * floor(floor(p.z) / TILESX)),
						interpolate->false, repeat->false
					)
				)
			);

			da = 0.05;
			db = 0.02;
			k  = 0.06;
			f  = 0.05;
			// da = 0.2;
			// db = 0.1;
			// k = 0.06;
			// f = 0.035;
			da = 0.05;
			db = 0.02;
			k  = 0.063;
			f  = 0.06;

			// initialize cube
			colorplot((0, 0), (statewidth, 0), "state", 
				pt = spacepoint(#);
				if(pt.y < 8 & |pt - target| <= EXTENT / 2,
					[random(), random(), 0],
					[0, 0, 0]
				)
			);


			computelaplacian(point) := (
				sum(apply(-1..1, dz,
					sum(apply(-1..1, dy,
						sum(apply(-1..1, dx,
							kernel_(dz+2)_(dy+2)_(dx+2) * get(point + [dx, dy, dz]);
						))
					))
				))
			);

			// deltas = [
			// 	[-1, 0, 0], [ 1, 0, 0],
			// 	[ 0,-1, 0], [ 0, 1, 0],
			// 	[ 0, 0,-1], [ 0, 0, 1]
			// ];

			newstate(hash) := (
				val       = imagergb((0,0), (statewidth,0), "state").r;
				laplacian = imagergb((0,0), (statewidth,0), "laplacian").r;
				deltax = da * laplacian.x - val.x * val.y * val.y + f * (1-val.x);
				deltay = db * laplacian.y + val.x * val.y * val.y - (k+f) * val.y;
				(val.x + deltax, val.y + deltay, 0)
			);
			ray(t) := origin + t * dir;
			raytrace()  := (
				c = 0;
				totalcolor = [0, 0, 0];
				totalalpha = 0;
				stepsize = zoom * EXTENT * 1.73205080757 / 512;
				repeat(512,
					val = voxelAt(ray(# * stepsize));
					// 	alpha = val^3 / 4;
					// 	totalalpha = totalalpha + alpha;
					// 	if(totalalpha <= 1,
					// 		color = [val, val^2, val^3];
					// 		totalcolor = totalcolor + alpha * color;
					// 	);
					c = c + val;
				);
				c = c / 64;
				[c, c^2, c^3]
			);

			// Renders isosurface with numerically approximated gradient
			raytraceiso() := (
				ISOVAL = 0.38;

				lightdir = [-1, -1, -1];
				lightdir = lightdir / |lightdir|;
				ambient     = [0.1, 0.2, 0.2];
				directional = [0.1, 0.5, 0.5];
				specular    = [1.0, 1.0, 1.0];

				c = 0;
				color = [0, 0, 0];
				totalalpha = 0;
				stepsize = zoom * EXTENT * 1.73205080757 / 512;
				flying = true;
				repeat(512,
					pos = ray(# * stepsize);
					if(flying & valAt(pos) >= ISOVAL,
						flying = false;
						normal = [
							valAt(pos+[1,0,0]) - valAt(pos-[1,0,0]),
							valAt(pos+[0,1,0]) - valAt(pos-[0,1,0]),
							valAt(pos+[0,0,1]) - valAt(pos-[0,0,1])
						];
						normal = normal / |normal|;
						eye = (origin - pos) / |pos - origin|;
						color =
							ambient + 
							directional * max(0, (lightdir * normal)) +
							specular * max(0, (lightdir * (eye - 2 * normal * (normal * eye)))^3)
							;
					);
				);
				color
			)
		</script>
		<script id="csmousedrag" type="text/x-cindyscript">
			d = mouse()-lastmouse;
			lambda = lambda-d.x;
			phi = phi-d.y;
			lastmouse = mouse();
		</script>
		<script id="csmousedown" type="text/x-cindyscript">
			lastmouse = mouse();
		</script>
		<script id="cskeydown" type="text/x-cindyscript">
		</script>
		<script type="text/javascript">
			CindyJS({
				scripts: "cs*",
				autoplay: true,
				ports: [{
					id: "CSCanvas",
					width: 800,
					height: 800,
					transform: [{
						visibleRect: [-1, 1, 1, -1]
					}]
				}]
			});
		</script>
	</body>
</html>
