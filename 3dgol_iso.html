<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<script type="text/javascript" src="https://cindyjs.org/dist/snapshot/Cindy.js"></script>
		<script type="text/javascript" src="https://cindyjs.org/dist/snapshot/CindyGL.js"></script>
		<title>3dgol</title>
	</head>

	<body style="background:#000;">
		<div id="CSCanvas" class="CindyJS-widget" style="position: relative; width: 512px; height: 512px;"></div>
		<script id="csdraw" type="text/x-cindyscript">
			//colorplot((0, 0), (statewidth, 0), "state", newstate(#));
			k = 0.05 + (|A-C| / |A-B| / 50);
			repeat(10, colorplot((0, 0), (statewidth, 0), "state", newstate(#)));

			// Ab hier: 3D
			origin = zoom * EXTENT * [
				cos(lambda)*cos(phi),
				sin(phi),
				sin(lambda)*cos(phi)
			] + target;
			mdir = (target-origin)/|(target-origin)|;
			v = cross([0,1,0], mdir);
			w = cross(mdir, v);
			v = v/|v|;
			w = w/|w|;
			colorplot(
				dir = mdir + #.x*v + #.y*w;
				raytraceiso()
			);
		</script>
		<script id="csinit" type="text/x-cindyscript">
			EXPONENT = 6;
			EXTENT = 2 ^ EXPONENT; // Extent of the cube for each dimension

			target = [EXTENT,EXTENT,EXTENT]/2;
			statewidth   = EXTENT * EXTENT;
			stateheight  = EXTENT;
			while(statewidth > 2 * stateheight,
				statewidth  = statewidth / 2;
				stateheight = stateheight * 2;
			);
			TILESX = statewidth / EXTENT;
			TILESY = stateheight / EXTENT;
			print(statewidth + " x " + stateheight);
			lambda = pi / 6;
			phi = pi / 8;
			zoom = 1.1;
			createimage("state", statewidth, stateheight);
			createimage("spect", statewidth, stateheight);
			
			spacepoint(t) := (
				mod(t.x, EXTENT),
				mod(t.y, EXTENT),
				floor(t.x / EXTENT) + TILESX * floor(t.y / EXTENT)
			);
			

			voxelAt(p) := (
				if(p.x<0 % p.y < 0 % p.z < 0 % p.x >= EXTENT % p.y >= EXTENT % p.z >= EXTENT,
					0
				,
					imagergb((0, 0), (statewidth, 0), "state",
						(floor(p.x) + EXTENT * mod(floor(p.z), TILESX),
						floor(p.y) + EXTENT * floor(floor(p.z) / TILESX)),
						interpolate->false, repeat->false
					).g
				)
			);

			// Trilinear interpolation of voxels (for isosurfaces)
			valAt(p) := (
				if(p.x<0 % p.y < 0 % p.z < 0 % p.x >= EXTENT % p.y >= EXTENT % p.z >= EXTENT,
					0
				,
					lz = p.z - floor(p.z);
					
					(1-lz) * imagergb((0, 0), (statewidth, 0), "state", (
						p.x + EXTENT * mod(floor(p.z), TILESX),
						p.y + EXTENT * floor(floor(p.z) / TILESX)
					), interpolate->true, repeat->false).g +
					lz *  imagergb((0, 0), (statewidth, 0), "state", (
						p.x + EXTENT * mod(ceil(p.z), TILESX),
						p.y + EXTENT * floor(ceil(p.z) / TILESX)
					), interpolate->true, repeat->false).g
				)
			);

			get(p) := (
				if(p.x<0, p.x = p.x + EXTENT, if(p.x>=EXTENT, p.x = p.x - EXTENT));
				if(p.y<0, p.y = p.y + EXTENT, if(p.y>=EXTENT, p.y = p.y - EXTENT));
				if(p.z<0, p.z = p.z + EXTENT, if(p.z>=EXTENT, p.z = p.z - EXTENT));
				if(p.x<0 % p.y < 0 % p.z < 0 % p.x >= EXTENT % p.y >= EXTENT % p.z >= EXTENT,
					[0, 0, 0]
				,
					imagergb((0, 0), (statewidth, 0), "state",
						(floor(p.x) + EXTENT * mod(floor(p.z), TILESX),
						floor(p.y) + EXTENT * floor(floor(p.z) / TILESX)),
						interpolate->false, repeat->false
					)
				)
			);

			da = 0.05;
			db = 0.02;
			k  = 0.06;
			f  = 0.05;
			// da = 0.2;
			// db = 0.1;
			// k = 0.06;
			// f = 0.035;
			da = 0.05;
			db = 0.02;
			k  = 0.063;
			f  = 0.06;

			// initialize cube
			colorplot((0, 0), (statewidth, 0), "state", 
				pt = spacepoint(#);
				if(pt.y < 8 & |pt - target| <= EXTENT / 2,
					[random(), random(), 0],
					[0, 0, 0]
				)
			);

			kernel = 6*[[
				[0.01, 0.03, 0.01],
				[0.03, 0.09, 0.03],
				[0.01, 0.03, 0.01]
			], [
				[0.03, 0.09, 0.03],
				[0.09, -0.98, 0.09],
				[0.03, 0.09, 0.03]
			], [
				[0.01, 0.03, 0.01],
				[0.03, 0.09, 0.03],
				[0.01, 0.03, 0.01]
			]]	
			;

			computelaplacian(point) := (
				sum(apply(-1..1, dz,
					sum(apply(-1..1, dy,
						sum(apply(-1..1, dx,
							kernel_(dz+2)_(dy+2)_(dx+2) * get(point + [dx, dy, dz]);
						))
					))
				))
			);

			// deltas = [
			// 	[-1, 0, 0], [ 1, 0, 0],
			// 	[ 0,-1, 0], [ 0, 1, 0],
			// 	[ 0, 0,-1], [ 0, 0, 1]
			// ];

			newstate(hash) := (
				pt = spacepoint(hash);
				val = get(pt);
				// laplacian = -6 * val + sum(apply(deltas, d, get(pt + d)));
				laplacian = computelaplacian(pt);
				deltax = da * laplacian.x - val.x * val.y * val.y + f * (1-val.x);
				deltay = db * laplacian.y + val.x * val.y * val.y - (k+f) * val.y;
				(val.x + deltax, val.y + deltay, 0)
			);
			ray(t) := origin + t * dir;
			raytrace()  := (
				c = 0;
				totalcolor = [0, 0, 0];
				totalalpha = 0;
				stepsize = zoom * EXTENT * 1.73205080757 / 512;
				repeat(512,
					val = voxelAt(ray(# * stepsize));
					// 	alpha = val^3 / 4;
					// 	totalalpha = totalalpha + alpha;
					// 	if(totalalpha <= 1,
					// 		color = [val, val^2, val^3];
					// 		totalcolor = totalcolor + alpha * color;
					// 	);
					c = c + val;
				);
				c = c / 64;
				[c, c^2, c^3]
			);

			// Renders isosurface with numerically approximated gradient
			raytraceiso() := (
				ISOVAL = 0.38;

				lightdir = [-1, -1, -1];
				lightdir = lightdir / |lightdir|;
				ambient     = [0.1, 0.2, 0.2];
				directional = [0.2, 0.3, 0.5];
				specular    = [1.0, 1.0, 1.0];

				c = 0;
				color = [0, 0, 0];
				totalalpha = 0;
				stepsize = zoom * EXTENT * 1.73205080757 / 512;
				flying = true;
				repeat(512,
					pos = ray(# * stepsize);
					if(flying & valAt(pos) >= ISOVAL,
						flying = false;
						normal = [
							valAt(pos+[1,0,0]) - valAt(pos-[1,0,0]),
							valAt(pos+[0,1,0]) - valAt(pos-[0,1,0]),
							valAt(pos+[0,0,1]) - valAt(pos-[0,0,1])
						];
						normal = normal / |normal|;
						eye = (origin - pos) / |pos - origin|;
						color =
							ambient + 
							directional * (lightdir * normal) +
							specular * (lightdir * (eye - 2 * normal * (normal * eye)))^3
							;
					);
				);
				color
			)
		</script>
		<script id="csmousedrag" type="text/x-cindyscript">
			if(mouse().x <= 0.85,
				d = mouse()-lastmouse;
				lambda = lambda-d.x;
				phi = phi-d.y;
				lastmouse = mouse();
			)
		</script>
		<script id="csmousedown" type="text/x-cindyscript">
			lastmouse = mouse();
		</script>
		<script id="cskeydown" type="text/x-cindyscript">
		</script>
		<script type="text/javascript">
			CindyJS({
				scripts: "cs*",
				autoplay: true, 
				geometry: [
					{alpha: 0, labeled: true, name: "A", pinned: true, type: "Free", pos: [0.9, -0.5, 1]},
					{alpha: 0, labeled: true, name: "B", pinned: true, type: "Free", pos: [0.9, 0.5, 1]},
					{args: ["A", "B"], labeled: false, name: "a", type: "Segment"},
					{args: ["a"], labeled: false, name: "C", type: "PointOnSegment", pos: [0.9, 0, 1]}
				],
				ports: [{
					id: "CSCanvas",
					width: 800,
					height: 800,
					transform: [{
						visibleRect: [-1, 1, 1, -1]
					}]
				}]
			});
		</script>
	</body>
</html>
