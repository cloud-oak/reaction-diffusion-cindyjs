<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="https://cindyjs.org/dist/snapshot/Cindy.js"></script>
    <script type="text/javascript" src="https://cindyjs.org/dist/snapshot/CindyGL.js"></script>
    <title>GOL 3D Schatten-Gradient</title>
  </head>

  <body>
    <div id="CSCanvas"></div>

    <script id="csinit" type="text/x-cindyscript">
      extent = 32;

      createimage("gol", extent, extent);
      colorplot([0, 0], [extent, 0], "gol", if(random()>.8,1,0)); //random values as starting image

      get(x, y) :=  imagergb([0, 0], [extent, 0], "gol", (x,y), interpolate->false, repeat->true).r; //Tourus world

      deltas = [(-1,-1), (-1,0), (-1,+1), (0,-1),  (0,+1), (+1,-1), (+1,0), (+1,+1)];
      countneighbors(x, y) := sum( apply(deltas, delta, get(delta.x + x, delta.y + y)));

      newstate(x, y) := (
        number = countneighbors(x, y); //number of living neighbors
        if(get(x, y) == 1,

          //if the cell lives then it will die if it has less than 2 neighbours or more than 3 neighbours
          if((number < 2) % (number > 3), 0, 1),

          //if cell was dead then 3 are required to be born
          if(number == 3, 1, 0)
        )
      );

      tiles = ceil(sqrt(extent));
      EXTENT = tiles*extent;
      createimage("history", EXTENT, EXTENT);
      t = 0;

      r = 1*extent;
      lambda = pi/2;
      phi = 0;

      //Lighting parameter
      ambient=0.5;

      onScroll(delta) := (
        r = r*exp(-delta/1000);
      );

      ray(t) := origin + t*dir;
      stepsize = (r + sqrt(3)*extent/2)/1000;
      raytracing() := (
        volume = 0;
        repeat(1000, volume = volume + evaluateVoxel(ray(#*stepsize)));
        1 - re(log(volume + 1))/log(500);
      );
      raytracingColor() := (
				outcol = (0,0,0,0);
        repeat(1000,
					outcol1 = evaluateVoxelColor(ray((1000-#)*stepsize));
					al=outcol1_4;
					outcol=[
						outcol_1*(1-al)+outcol1_1*al,
						outcol_2*(1-al)+outcol1_2*al,
						outcol_3*(1-al)+outcol1_3*al,
						1
					]
        	//1 - re(log(volume + 1))/log(500);
      	);
			);
      raytracingColorfb() := (
				outcol = (0,0,0,0);
        al=0;
        repeat(1000,
          pos=ray(#*stepsize);
					outcol1 = colorize(evaluateVoxelColor(pos));
          phong = lighting(pos);
          diffuse=phong_1;
          specular =0.0000001* phong_2;
          outcol1=[(diffuse+ambient+specular)*outcol1_1,(diffuse+ambient+specular)*outcol1_2,(diffuse+ambient+specular)*outcol1_3,outcol1_4];
					al1=outcol1_4;
          al=al+al1*(1-al);
					outcol=[
						outcol_1+outcol1_1*al1*(1-al),
						outcol_2+outcol1_2*al1*(1-al),
						outcol_3+outcol1_3*al1*(1-al),
						al
					]
        	//1 - re(log(volume + 1))/log(500);
      	);
			);
      evaluateVoxel(p) := (
        if((min(p) < 0) % (extent < max(p)), 0,
          T = mod(ceil(p.y)-extent+t,extent);
          imagergb([0, 0], [EXTENT, 0], "history", [p.x + extent*mod(T, tiles),
            p.z + extent*floor(T/tiles)], interpolate->false).r
        )
      );
      evaluateVoxelColor(p) := (
        if((min(p) < 0) % (extent < max(p)), (0,0,0,0),
          T = mod(ceil(p.y)- extent +t,extent);
          imagergba([0, 0], [EXTENT, 0], "history", [p.x+ extent*mod(T, tiles),
            p.z + extent*floor(T/tiles)], interpolate->false)
        )
      );

      colorize(erg):=(
				if(erg_1==0,col=(0,0,0,0));
				if(erg_1==1 & erg_2==0 & erg_2<0.2, col=[1,0,0,0.2]);
				if(erg_1==1 & erg_2>0 & erg_2<0.27, col=[1,0.25,0,0.2]);
				if(erg_1==1 & erg_2>0.27 & erg_2<0.57, col=[1,0.5,0,0.2]);
				if(erg_1==1 & erg_2>0.57 & erg_2<0.77, col=[1,0.75,0,0.2]);
				if(erg_1==1 & erg_2>0.77 & erg_2<1.1, col=[1,1,0,0.2]);
				col;
			);

      lighting(p):=(
        //voxmid=[ceil(p.x),ceil(p.y),ceil(p.z)]-[0.5,0.5,0.5];
        //normal=p-voxmid;
        normal=gradient(p,0.2);
        normal=normal/abs(normal);
        lightdir=(light-p);
        lightdir=lightdir/abs(lightdir);
        reflectdir=-lightdir+2*(lightdir*normal)*normal;
        specular=max((origin*reflectdir),0.0)^(2);
        diffuse=max((normal*lightdir),0.0);
        [diffuse, specular];
      );

      gradient(p,h):= (
        hdeltas=[(h,0,0),(0,h,0),(0,0,h)];
        //gradient=1/(2*h)*[evaluateVoxel(p+hdeltas_1)-evaluateVoxel(p-hdeltas_1),evaluateVoxel(p+hdeltas_2)-evaluateVoxel(p-hdeltas_2),evaluateVoxel(p+hdeltas_3)-evaluateVoxel(p-hdeltas_3)];
        gradient=1/(-2*h)*(apply(hdeltas,hdelta,evaluateVoxel(p+hdelta))-apply(hdeltas,hdelta,evaluateVoxel(p-hdelta)));
      );

			colorcode(p) := (
				if(get(p.x,p.y)==1, countneighbors(p.x, p.y)/4);
			);

      resetclock();
    </script>

    <script id="csdraw" type="text/x-cindyscript">
      colorplot([0, 0], [extent, 0], "gol", newstate(#.x, #.y)); //overwrite texture "gol"
      colorplot([0, 0], [extent, 0], "gol", [get(#.x, #.y),colorcode(#), 0,1]); //overwrite texture "gol"

      X = extent*mod(t, tiles);
      Y = extent*floor(t/tiles);
      canvas([0, 0], [EXTENT, 0], "history", drawimage([X, Y], [X + extent, Y], "gol", interpolate->false));

      //lambda = pi/2;
      target = extent*[1, 1, 1]/2;
      origin = r*[cos(lambda)*cos(phi), sin(phi), sin(lambda)*cos(phi)] + target;
      light = r*[cos(lambda)*cos(phi), sin(phi), sin(lambda)*cos(phi)] + target;
      mdir = (target - origin)/|(target - origin)|;
      v = cross([0, 1, 0], mdir);
      w = cross(mdir, v);
      v = v/|v|;
      w = w/|w|;


      colorplot(
        dir = mdir + #.x*v + #.y*w;
        dir = dir/|dir|;
        raytracingColorfb();
      );
      drawimage((-1,0),(0,0),"gol", interpolate->false);
      t = mod(t + 1, extent);
    </script>

    <script id="csmousedown" type="text/x-cindyscript">
      lastmouse = mouse();
    </script>

    <script id="csmousedrag" type="text/x-cindyscript">
      d = mouse()-lastmouse;
      lambda = lambda-d.x;
      phi = phi-d.y;
      lastmouse = mouse();
    </script>

    <script type="text/javascript">
    var cdy = CindyJS({
      scripts: "cs*",
      autoplay: true,
      ports: [{
        id: "CSCanvas",
        width: 512,
        height:512,
        transform: [{
          visibleRect: [-1, 1, 1, -1]
        }]
      }],
      oninit: function(){
        cdy.canvas.addEventListener("wheel", function() {
          cdy.evokeCS('onScroll(' + event.wheelDelta + ')');
        });
      }
    });
    </script>
  </body>
</html>
